/*
 * sdcarddriver.h
 *
 *  Created on: Apr 6, 2024
 *      Author: Evgeny Darichev
 */

#ifndef INC_SDCARDDRIVER_H_
#define INC_SDCARDDRIVER_H_

#include <initializer_list>
#include <array>
#include <delay.h>

struct SPIPins
{
    GPIO_TypeDef* portMOSI {};
    GPIO_TypeDef* portMISO {};
    GPIO_TypeDef* portCS {};
    GPIO_TypeDef* portSCK {};
    uint16_t pinMOSI = 0;
    uint16_t pinMISO = 0;
    uint16_t pinCS = 0;
    uint16_t pinSCK = 0;
};

#define SDCARD_CMD_START 0x40
#define SDCARD_CMD(n) (SDCARD_CMD_START + n)

enum class SDCardDriverError : uint8_t
{
    NotReady = 3,
};

class SDCardDriver
{
protected:
    SPIPins _pins;
    SPI_HandleTypeDef *hspi{};
    uint32_t Timeout = 1000;
public:

    SDCardDriver(const SPIPins &pins)
        : _pins(pins)
    {

    }

    void sendByte(uint8_t b)
    {
        while(!__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
            ;
        HAL_SPI_Transmit(hspi, &b, 1, Timeout);
    }

    void sendBuffer(uint8_t *buf, uint16_t size)
    {
        while(!__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
            ;
        HAL_SPI_Transmit(hspi, buf, size, Timeout);
    }

    inline void sendCmdArgs(uint8_t (&args)[4])
    {
        sendBuffer(args, 4);
    }

    void sendCommand(uint8_t cmd, uint8_t (&args)[4]){
        // Команды, передаваемые по интерфейсу SPI, имеют размер 48 бит. Формат команд:
        // Бит 47 (крайний слева) всегда содержит значение 0.
        // Бит 46 всегда содержит значение 1.
        // Биты 45..40 содержат индекс команды.
        // Биты 39..8 содержат аргументы команды.
        // Биты 7..1 содержат CRC от предыдущих бит.
        // Бит 0 всегда содержит значение 1.

        uint8_t response = 0xFF;
        if (SD_ReadyWait() != 0xFF)
            return response;

        uint8_t crc = 0b0000'0001;
        switch (cmd) {
        case SDCARD_CMD(0): crc = 0x95; break;
        case SDCARD_CMD(8): crc = 0x87; break;
        }
        sendByte(0b0100'0000 | cmd);
        sendCmdArgs(args);
        sendByte(crc);

        if (cmd == SDCARD_CMD(12))
            receiveByte();
        uint8_t n = 16;
        do {
            response = receiveByte();
        } while ((response & 0x80) && --n);
        return response;
    }
    /**
     */
    SDCardDriverError init()
    {
//        1. После включения питания необходимо подождать минимум 1 мс.
        Delay::wait(1);
//        2. Сформировать минимум 74 переключения тактового сигнала для карты.
//        Линии CS и MOSI должны быть в состоянии логической единицы.
        HAL_GPIO_WritePin(_pins.portCS, _pins.pinCS, GPIO_PIN_SET);
        HAL_GPIO_WritePin(_pins.portMOSI, _pins.pinMOSI, GPIO_PIN_SET);
        const auto n = 74 + 10;
        for (auto i = 0; i < n; ++i) {
            HAL_GPIO_WritePin(_pins.portSCK, _pins.pinSCK, GPIO_PIN_SET);
            HAL_GPIO_WritePin(_pins.portSCK, _pins.pinSCK, GPIO_PIN_RESET);
        }
//        3. Сформировать команду CMD0. Команда CMD0 выполняет сброс карты SD.
        uint8_t argsCMD0[] = {0x0, 0x0, 0x0, 0x0};
//        4. Ожидать ответа на команду CMD0. Ответом является ответ типа R1.
//        В случае, если ответ R1 не пришел за 16 тактов частоты инициализации,
//        переход к шагу 3. Если ответ R1 от карты поступил, но отличается от
//        значения 0x01 (карта не перешла в состояние инициализации), переход
//        к шагу 3, иначе переход к шагу 5.
        uint8_t response = 0;
        const uint8_t attemps = 10;
        uint n = attemps;
        do {
            response = sendCommand(SDCARD_CMD(0), argsCMD0);
        } while ((response != 0x1) && (--n));
        if ((response != 0x1) && (--n)) {
            // error
            return SDCardDriverError::NotReady;
        }
//        5. Сформировать команду CMD8. Команда отправляет карте напряжения
//        питания контроллера и тестовую последовательность для проверки линии.
//        6. Ожидать ответа на команду CMD8. Ответом являет ответ типа R7.
//        В случае, если в ответе содержится бит, что команда не поддерживается,
//        переход к шагу 7, иначе, если тестовая последовательность и напряжения
//        питания карты совпадают с отправленными контроллером, переход
//        к шагу 17, иначе к шагу 13.
//        7. Отправка команды CMD55. Команда CMD55 сообщает карте, что
//        следующая команда будет нестандартная.
//        8. Ожидание ответа на команду CMD55. Ответом является ответ типа R1.
//        Если ответ не равен 0x01 (произошла ошибка при выполнении команды),
//        переход к шагу 7, иначе к шагу 9.
//        9. Отправка команды ACMD41. Команда ACMD41 сообщает карте, что
//        поддерживает карты SDSC (параметр 0x00000000) и запускает процесс инициализации.
//        10. Ожидание ответа на команду ACMD41. Ответом является ответ типа R1.
//        В случае если ответе содержится бит, что команда не поддерживается,
//        переход к шагу 11. Иначе, если ответ равен 0x00 (инициализация завершена)
//        переход к шагу 14, в противном случае переход к шагу 7.
//        11. Отправка команды CMD1. Команда CMD1 аналогична команде ACMD41.
//        12. Ожидание ответа на команду CMD1. Ответом являет ответ типа R1.
//        В случае если в ответе содержится бит, что команда не поддерживается,
//        переход к шагу 13, иначе, если ответ равен 0x00 (инициализация завершена),
//        переход к шагу 14, в противном случае переход к шагу 11.
//        13. Состояние ошибки. Инициализация завершилась неудачно,
//        дальнейшая работа невозможна. Выход из этого состояния не предусмотрен.
//        14 Отправка команды CMD16. Команда используется для настройки в карте
//        режима работы с блоками, размерами 512 байт.
//        15. Ожидание ответа на команду CMD16. Ответом является ответ типа R1.
//        В случае, если ответ равен 0x00 (команда завершена удачно) переход
//        к шагу 16, иначе к шагу 13.
//        16. Состояние удачного завершения инициализации. Можно начинать
//        работать с данными на карте. Выход из алгоритма.
//        17. Отправка команды CMD55. Команда CMD55 сообщает карте, что
//        следующая команда будет нестандартная.
//        18. Ожидание ответа на команду CMD55. Ответом является ответ типа R1.
//        Если ответ не равен 0x01 (произошла ошибка при выполнении команды),
//        переход к шагу 17, иначе к шагу 19.
//        19. Отправка команды ACMD41. Отправка команды ACMD41. Команда ACMD41
//        сообщает карте, что поддерживает карты SDHC (параметр 0x40000000) и
//        запускает процесс инициализации.
//        20. Ожидание ответа на команду ACMD41. Ответом является ответ типа R1.
//        В случае если ответе содержится бит, что команда не поддерживается,
//        переход к шагу 13. Иначе, если ответ равен 0x00 (инициализация
//        завершена) переход к шагу 21, в противном случае переход к шагу 17.
//        21. Отправка команды CMD58. Чтение регистра конфигурации карты.
//        22. Ожидание ответа на команду CMD58. Ответом является ответ типа R3.
//        В случае, если в ответе установлен бит, что карта работает с адресами
//        блоков по 512 байт, переход к шагу 16, иначе к шагу 14.
//
//        После завершения инициализации с картой можно работать блоками по 512 байт с тактовой частотой в 25 МГц.
    }
};

#endif /* INC_SDCARDDRIVER_H_ */
